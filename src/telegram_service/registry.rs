// src/telegram_service/registry.rs

use solana_sdk::signature::Keypair;
use tokio::sync::mpsc::UnboundedSender;
use crate::telegram_service::commands::Commander;
use crate::telegram_service::tl_engine::ServiceCommand;
use crate::params::{WETH, WBTC, WSOL, USDC};
use tokio::sync::Notify;
use chrono::Utc;
use crate::wirlpool_services::wirlpool::position_mode;
use crate::wirlpool_services::wirlpool::open_with_funds_check_universal;
use crate::wirlpool_services::{
    get_info::fetch_pool_position_info,
    wirlpool::{harvest_whirlpool_position, summarize_harvest_fees,
        close_whirlpool_position, close_all_positions, list_positions_for_owner
    },
};
use crate::wirlpool_services::wirlpool::Mode;
use orca_whirlpools_core::tick_index_to_price;
use orca_tx_sender::Signer;
use crate::database::triggers;
use anyhow::anyhow;
use orca_whirlpools::PositionOrBundle;
use tokio::time::sleep;
use crate::utils::{self, sweep_dust_to_usdc};
use std::time::Duration;
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;
use std::sync::Arc;
use crate::utils::utils::{init_rpc, load_wallet};
use crate::database::triggers::Trigger;
use crate:: wirlpool_services::wirlpool::{increase_liquidity_partial, decrease_liquidity_partial, refresh_balances};

/// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–æ–º–∞–Ω–¥
pub fn register_commands(commander: Arc<Commander>, tx: UnboundedSender<ServiceCommand>, close_ntf:  Arc<Notify>) {
    let tx = Arc::new(tx);

    {
        let c: Arc<Commander> = Arc::clone(&commander);
        let t = Arc::clone(&tx);
        commander.add_command(&["info"], move |_params| {
            let c2 = Arc::clone(&c);
            let t2: Arc<UnboundedSender<ServiceCommand>> = Arc::clone(&t);
            async move {
                let tree = c2.show_tree();
                let _ = t2.send(ServiceCommand::SendMessage(
                    format!("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n{}", tree),
                ));
            }
        });
    }

    commander.add_command(&["on"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);
            async move {
                // –í—ã–∫–ª—é—á–∞–µ–º —Ñ–ª–∞–≥ –≤ –ë–î
                let mut t = Trigger {
                    name: "auto_trade".into(),
                    state: false,
                    position: "opening".into(),
                };
                match triggers::upsert_trigger(&t).await {
                    Ok(_) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            "‚úÖ Trigger `auto_trade` on".into(),
                        ));
                    }
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            format!("‚ùå Failed to on trigger: {}", e),
                        ));
                    }
                }
            }
        }
    });

    commander.add_command(&["off"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);
            async move {
                let mut t = Trigger {
                    name: "auto_trade".into(),
                    state: true,
                    position: "opening".into(),
                };
                match triggers::upsert_trigger(&t).await {
                    Ok(_) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            "‚úÖ Trigger `auto_trade` enabled".into(),
                        ));
                    }
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            format!("‚ùå Failed to enable trigger: {}", e),
                        ));
                    }
                }
            }
        }
    });

    commander.add_command(&["safe"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);
            async move {
                match utils::swap_excess_to_usdc(WSOL, 9, 0.10).await {
                    Ok(report) => { let _ = tx.send(ServiceCommand::SendMessage(report)); }
                    Err(e)     => { let _ = tx.send(ServiceCommand::SendMessage(format!("Error: {e}"))); }
                }
            }
        }
    });

    commander.add_command(&["swap", "dust"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);

            // ¬´–ø—ã–ª—å¬ª, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏–º –æ–±–º–µ–Ω—è—Ç—å –Ω–∞ USDC.
            // –ú–æ–∂–Ω–æ —Å–≤–æ–±–æ–¥–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ (mint, decimals).
            const DUST_TOKENS: [(&str, u8); 2] = [
                (WETH, 8),
                (WBTC, 8),
            ];

            async move {
                let _ = tx.send(ServiceCommand::SendMessage(
                    "üîÑ –ò—â—É ¬´–ø—ã–ª—å¬ª (WETH, WBTC)‚Ä¶".into(),
                ));

                match sweep_dust_to_usdc(&DUST_TOKENS).await {
                    Ok(report) => {
                        let _ = tx.send(ServiceCommand::SendMessage(report));
                    }
                    Err(err) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–≤–∏–ø–µ –ø—ã–ª–∏: {err:?}"),
                        ));
                    }
                }
            }
        }
    });

    commander.add_command(&["close", "on"], {
        let tx = Arc::clone(&tx);
        let close_ntf = close_ntf.clone();
        move |_params| {
            let tx = Arc::clone(&tx);
            let close_ntf = close_ntf.clone(); 
            async move {
                // –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                let _ = tx.send(ServiceCommand::SendMessage(
                    "üîí –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–∫—Ä—ã–≤–∞—Ç—å –í–°–ï –ø–æ–∑–∏—Ü–∏–∏‚Ä¶".into(),
                ));
    
                // –≤—Å—ë —Ç—è–∂—ë–ª–æ–µ ‚Äì –≤ —Ñ–æ–Ω–µ
                let tx_bg = Arc::clone(&tx);
                tokio::spawn(async move {
                    if let Err(err) = close_all_positions(300, None).await {
                        let _ = tx_bg.send(ServiceCommand::SendMessage(
                            format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–π: {err:?}"),
                        ));
                        return;
                    }
    
                    let _ = tx_bg.send(ServiceCommand::SendMessage(
                        "‚úÖ –ó–∞–ø—Ä–æ—Å—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã, –∂–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π‚Ä¶".into(),
                    ));
    
                    tokio::time::sleep(Duration::from_secs(2)).await;
                    close_ntf.notify_waiters();
    
                    match list_positions_for_owner(None).await {
                        Ok(positions) if positions.is_empty() => {
                            
                            let _ = tx_bg.send(ServiceCommand::SendMessage(
                                "üéâ –í—Å–µ –ø–æ–∑–∏—Ü–∏–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç—ã.".into(),
                            ));

                            let mut t = Trigger {
                                name: "auto_trade".into(),
                                state: true,
                                position: "opening".into(),
                            };
                            let t = triggers::upsert_trigger(&t).await;
                            tokio::time::sleep(Duration::from_secs(10)).await;

                        }
                        Ok(positions) => {
                            let mut msg = String::from("‚ö†Ô∏è –û—Å—Ç–∞–ª–∏—Å—å –Ω–µ–∑–∞–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏:\n");
                            for p in positions {
                                match p {
                                    PositionOrBundle::Position(hp) =>
                                        msg.push_str(&format!("- mint: {}\n",
                                            hp.data.position_mint)),
                                    PositionOrBundle::PositionBundle(pb) =>
                                        msg.push_str(&format!("- bundle account: {}\n",
                                            pb.address)),
                                }
                            }
                            let _ = tx_bg.send(ServiceCommand::SendMessage(msg));
                        }
                        Err(err) => {
                            let _ = tx_bg.send(ServiceCommand::SendMessage(
                                format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–∑–∏—Ü–∏–π: {err:?}"),
                            ));
                        }
                    }
                });
            }
        }
    });
    


    
    commander.add_command(&["close", "all"], {
        let tx = Arc::clone(&tx);
        let close_ntf = close_ntf.clone();
        move |_params| {
            let tx = Arc::clone(&tx);
            let close_ntf = close_ntf.clone(); 
            async move {
                // –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                let _ = tx.send(ServiceCommand::SendMessage(
                    "üîí –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–∫—Ä—ã–≤–∞—Ç—å –í–°–ï –ø–æ–∑–∏—Ü–∏–∏‚Ä¶".into(),
                ));
    
                // –≤—Å—ë —Ç—è–∂—ë–ª–æ–µ ‚Äì –≤ —Ñ–æ–Ω–µ
                let tx_bg = Arc::clone(&tx);
                tokio::spawn(async move {
                    if let Err(err) = close_all_positions(300, None).await {
                        let _ = tx_bg.send(ServiceCommand::SendMessage(
                            format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–π: {err:?}"),
                        ));
                        return;
                    }
    
                    let _ = tx_bg.send(ServiceCommand::SendMessage(
                        "‚úÖ –ó–∞–ø—Ä–æ—Å—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã, –∂–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π‚Ä¶".into(),
                    ));
    
                    tokio::time::sleep(Duration::from_secs(2)).await;
                    close_ntf.notify_waiters();
    
                    match list_positions_for_owner(None).await {
                        Ok(positions) if positions.is_empty() => {
                            
                            let _ = tx_bg.send(ServiceCommand::SendMessage(
                                "üéâ –í—Å–µ –ø–æ–∑–∏—Ü–∏–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç—ã.".into(),
                            ));
                            tokio::time::sleep(Duration::from_secs(10)).await;
                        }
                        Ok(positions) => {
                            let mut msg = String::from("‚ö†Ô∏è –û—Å—Ç–∞–ª–∏—Å—å –Ω–µ–∑–∞–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏:\n");
                            for p in positions {
                                match p {
                                    PositionOrBundle::Position(hp) =>
                                        msg.push_str(&format!("- mint: {}\n",
                                            hp.data.position_mint)),
                                    PositionOrBundle::PositionBundle(pb) =>
                                        msg.push_str(&format!("- bundle account: {}\n",
                                            pb.address)),
                                }
                            }
                            let _ = tx_bg.send(ServiceCommand::SendMessage(msg));
                        }
                        Err(err) => {
                            let _ = tx_bg.send(ServiceCommand::SendMessage(
                                format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–∑–∏—Ü–∏–π: {err:?}"),
                            ));
                        }
                    }
                });
            }
        }
    });
    
    

    
    commander.add_command(&["close", "off"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);
            async move {
                // –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äì —Å—Ä–∞–∑—É
                let _ = tx.send(ServiceCommand::SendMessage(
                    "üîí –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –∏ –≤—ã–∫–ª—é—á–∞–µ–º—Å—è‚Ä¶".into(),
                ));
    
                // —Ç—è–∂—ë–ª—É—é —Ä–∞–±–æ—Ç—É + –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ ‚Äî –≤ —Ñ–æ–Ω–µ
                let tx_bg = Arc::clone(&tx);
                tokio::spawn(async move {
                    if let Err(err) = close_all_positions(300, None).await {
                        let _ = tx_bg.send(ServiceCommand::SendMessage(
                            format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–π: {err:?}"),
                        ));
                    } else {
                        let rpc = &utils::utils::init_rpc();
                        let payer = match utils::utils::load_wallet() {
                            Ok(kp) => kp,
                            Err(e) => {
                                let _ = tx_bg.send(ServiceCommand::SendMessage(
                                    format!("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ—à–µ–ª—ë–∫: {e}"),
                                ));
                                return; // –ø—Ä–µ–∫—Ä–∞—â–∞–µ–º —Ä–∞–±–æ—Ç—É –≤ —ç—Ç–æ–º —Ñ–æ–Ω–µ
                            }
                        };
                        let wallet: Pubkey  = payer.pubkey();
                        const TOKENS: [(&str, u8); 2] = [
                            (WSOL, 9),
                            (USDC, 6),
                        ];
                        let balances = match utils::balances_for_mints(&rpc, &wallet, &TOKENS).await {
                            Ok(v) => v,
                            Err(e) => {
                                let _ = tx_bg.send(ServiceCommand::SendMessage(
                                    format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–æ–≤: {e}"),
                                ));
                                return;
                            }
                        };

                        let mut report = String::from("‚úÖ –ü–æ–∑–∏—Ü–∏–∏ –∑–∞–∫—Ä—ã—Ç—ã. –¢–µ–∫—É—â–∏–µ –±–∞–ª–∞–Ω—Å—ã:\n");
                        if balances.is_empty() {
                            report.push_str("  ‚Äî –≤—Å–µ –æ—Å—Ç–∞—Ç–∫–∏ —Ä–∞–≤–Ω—ã –Ω—É–ª—é.\n");
                        } else {
                            for (mint, _dec, bal) in balances {
                                report.push_str(&format!("  ‚Ä¢ {}: {:.6}\n", mint, bal));
                            }
                        }
                        let _ = tx_bg.send(ServiceCommand::SendMessage(report));
                    }
    
                    // –¥–∞—ë–º Telegram-—Ü–∏–∫–ª—É —Å–µ–∫—É–Ω–¥—É, —á—Ç–æ–±—ã —Ä–µ–∞–ª—å–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
                    tokio::time::sleep(Duration::from_secs(10)).await;
                    std::process::exit(0);
                });
            }
        }
    });
    

    commander.add_command(&["inc"], {
        let tx = Arc::clone(&tx);
    
        move |params| {
            let tx = Arc::clone(&tx);
    
            // —ç—Ç–∞ –æ–±—ë—Ä—Ç–∫–∞ –í–û–ó–í–†–ê–©–ê–ï–¢ Send-future
            async move {
                // –∫–ª–æ–Ω–∏—Ä—É–µ–º, –ø–æ—Ç–æ–º—É —á—Ç–æ params –ø—Ä–∏–¥—É—Ç –ø–æ &'a Vec<String>
                let params_owned = params.clone();
                // Handle —Ç–µ–∫—É—â–µ–≥–æ runtime (–Ω—É–∂–µ–Ω –≤–Ω—É—Ç—Ä–∏ blocking-–ø–æ—Ç–æ–∫–∞)
                let handle = tokio::runtime::Handle::current();
    
                // –∑–∞–ø—É—Å–∫–∞–µ–º "–Ω–µ—Å–µ–Ω–¥–æ–≤—É—é" –ª–æ–≥–∏–∫—É –≤ blocking-–ø—É–ª–µ
                let _ = tokio::task::spawn_blocking(move || {
                    handle.block_on(run_inc_command(params_owned, tx))
                })
                .await;               // `JoinHandle` ‚Äî Send, –≤—Å—ë –û–ö
            }
        }
    });


    // --- SHORT OPEN: short --uint
    commander.add_command(&["short"], {
        let tx = Arc::clone(&tx);
        move |params| {
            let tx = Arc::clone(&tx);
            async move {
                let amount = params.get(0)
                    .and_then(|v| v.parse::<f64>().ok())
                    .unwrap_or(0.0);
                if amount <= 0.0 {
                    let _ = tx.send(ServiceCommand::SendMessage("–£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É –≤ USDT: short --300".into()));
                    return;
                }
                let mut hl = match crate::exchange::hyperliquid::hl::HL::new_from_env().await {
                    Ok(h) => h,
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(format!("HL init error: {e}")));
                        return;
                    }
                };
                match hl.open_market_order("SOLUSDT", "Sell", amount, false, 0.0).await {
                    Ok((cloid, px)) => {
                        let _ = tx.send(ServiceCommand::SendMessage(format!(
                            "‚úÖ Short –æ—Ç–∫—Ä—ã—Ç –Ω–∞ {:.2} USDT\nOrder ID: {}\n–¶–µ–Ω–∞: {:.4}", amount, cloid, px
                        )));
                    }
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(format!("–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —à–æ—Ä—Ç–∞: {e}")));
                    }
                }
            }
        }
    });

    // --- SHORT CLOSE: short close
    commander.add_command(&["short", "close"], {
        let tx = Arc::clone(&tx);
        move |_params| {
            let tx = Arc::clone(&tx);
            async move {
                let mut hl = match crate::exchange::hyperliquid::hl::HL::new_from_env().await {
                    Ok(h) => h,
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(format!("HL init error: {e}")));
                        return;
                    }
                };
                // 1. –ü–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é
                match hl.get_position("SOLUSDT").await {
                    Ok(Some(pos)) if pos.size > 0.0 => {
                        // 2. –ó–∞–∫—Ä—ã—Ç—å –µ—ë (reduce_only = true, amount_coins = pos.size)
                        match hl.open_market_order("SOLUSDT", "Short", 0.0, true, pos.size).await {
                            Ok((cloid, close_px)) => {
                                // 3. –£–∑–Ω–∞—Ç—å –±–∞–ª–∞–Ω—Å
                                match hl.get_balance().await {
                                    Ok(bal) => {
                                        let _ = tx.send(ServiceCommand::SendMessage(
                                            format!(
                                                "‚úÖ –®–æ—Ä—Ç –ø–æ SOLUSDT ({:.4} –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤) —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç (order {})\n–ë–∞–ª–∞–Ω—Å: ${:.2}",
                                                pos.size, cloid, bal
                                            )
                                        ));
                                    }
                                    Err(e) => {
                                        let _ = tx.send(ServiceCommand::SendMessage(
                                            format!(
                                                "‚úÖ –ü–æ–∑–∏—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∞, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å: {e}"
                                            )
                                        ));
                                    }
                                }
                            }
                            Err(e) => {
                                let _ = tx.send(ServiceCommand::SendMessage(
                                    format!("–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏: {e}")
                                ));
                            }
                        }
                    }
                    Ok(_) => {
                        let _ = tx.send(ServiceCommand::SendMessage("–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —à–æ—Ä—Ç–∞ –ø–æ SOLUSD".into()));
                    }
                    Err(e) => {
                        let _ = tx.send(ServiceCommand::SendMessage(
                            format!("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏: {e}")
                        ));
                    }
                }
            }
        }
    });


}


#[allow(clippy::too_many_lines)]
pub async fn run_inc_command(
    params: Vec<String>,
    tx:     std::sync::Arc<tokio::sync::mpsc::UnboundedSender<ServiceCommand>>,
) {
    use crate::params::{WSOL, USDC, OVR};
    use crate::types::PoolConfig;
    use crate::utils::utils::{init_rpc, load_wallet};

    // ‚îÄ‚îÄ 0. –ü–∞—Ä—Å–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if params.len() < 3 {
        let _ = tx.send(ServiceCommand::SendMessage(
            "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: inc --<from> --<to> --<pct>".into(),
        ));
        return;
    }
    let from_idx = params[0].parse::<usize>().unwrap_or(0);
    let to_idx   = params[1].parse::<usize>().unwrap_or(0);
    let pct      = params[2].parse::<f64>().unwrap_or(0.0);

    if !(1..=3).contains(&from_idx) || !(1..=3).contains(&to_idx) || from_idx == to_idx {
        let _ = tx.send(ServiceCommand::SendMessage(
            "–ù–æ–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–π –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å 1..3 –∏ —Ä–∞–∑–ª–∏—á–∞—Ç—å—Å—è".into(),
        ));
        return;
    }
    if !(0.0 < pct && pct <= 100.0) {
        let _ = tx.send(ServiceCommand::SendMessage(
            "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ (0;100]".into(),
        ));
        return;
    }

    // ‚îÄ‚îÄ 1. –ë–µ—Ä—ë–º —Ç—Ä–∏ –ø–æ–∑–∏—Ü–∏–∏ –≤–ª–∞–¥–µ–ª—å—Ü–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let list = match list_positions_for_owner(None).await {
        Ok(v) if v.len() == 3 => v,
        Ok(v) => {
            let _ = tx.send(ServiceCommand::SendMessage(
                format!("–û–∂–∏–¥–∞–ª–æ—Å—å 3 –ø–æ–∑–∏—Ü–∏–∏, –Ω–∞–π–¥–µ–Ω–æ {}", v.len()),
            ));
            return;
        }
        Err(e) => {
            let _ = tx.send(ServiceCommand::SendMessage(
                format!("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏–∏: {e}"),
            ));
            return;
        }
    };

    // ‚îÄ‚îÄ 2. –°–æ—Ä—Ç–∏—Ä—É–µ–º ¬´—Å–≤–µ—Ä—Ö—É ‚Üí –≤–Ω–∏–∑¬ª (–ø–æ –≤–µ—Ä—Ö–Ω–µ–º—É —Ü–µ–Ω–æ–≤–æ–º—É –ø—Ä–µ–¥–µ–ª—É) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut info = Vec::<(Pubkey, f64)>::new();
    for p in &list {
        if let PositionOrBundle::Position(hp) = p {
            let up = upper_price(hp.data.tick_upper_index, 9, 6); // SOL/USDC
            info.push((hp.data.position_mint, up));
        }
    }
    info.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

    let mint_from = info[from_idx - 1].0;
    let mint_to   = info[to_idx   - 1].0;

    // ‚îÄ‚îÄ 3. –ü—Ä–∏–≥–æ—Ç–æ–≤–∏–º PoolConfig (–Ω—É–∂–µ–Ω increase_‚Ä¶) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let whirl_pk = if let PositionOrBundle::Position(hp) = list.first().unwrap() {
        hp.data.whirlpool
    } else { unreachable!() };

    let pool_cfg = PoolConfig {
        amount: 0.0,
        program: "".to_string(),
        name: "SOL/USDC".to_string(),
        pool_address: whirl_pk.to_string(),
        position_1: None, position_2: None, position_3: None,
        mint_a: WSOL.to_string(), mint_b: USDC.to_string(),
        decimal_a: 9, decimal_b: 6,

        date_opened:           Utc::now(),     // –∏–ª–∏ –ª—é–±–∞—è –¥—Ä—É–≥–∞—è –∑–∞–≥–ª—É—à–µ—á–Ω–∞—è –¥–∞—Ç–∞
        is_closed:             false,          // –ø–æ–∑–∏—Ü–∏—è –µ—â—ë –Ω–µ –∑–∞–∫—Ä—ã—Ç–∞
        commission_collected_1: 0.0,            // –ø–æ–∫–∞ –∫–æ–º–∏—Å—Å–∏–π –Ω–µ—Ç
        commission_collected_2: 0.0,
        commission_collected_3: 0.0,
        total_value_open:      0.0,            // –ª–∏–±–æ –∏—Å—Ö–æ–¥–Ω–∞—è TVL
        total_value_current:   0.0,            // –ª–∏–±–æ —Ç–µ–∫—É—â–µ–µ TVL
    };

    // ‚îÄ‚îÄ 4. –ó–∞–º–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å—ã ¬´–¥–æ¬ª ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let rpc    = init_rpc();
    let wallet = load_wallet().unwrap();
    let dec_b  = 6u8;

    let (sol_before, usdc_before) = refresh_balances(
        &rpc, &wallet.pubkey(), &Pubkey::from_str(USDC).unwrap(), dec_b,
    )
    .await
    .expect("refresh_balances failed");

    // ‚îÄ‚îÄ 5. –°–Ω–∏–º–∞–µ–º —á–∞—Å—Ç—å –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let _ = tx.send(ServiceCommand::SendMessage(
        format!("üîÑ –°–Ω–∏–º–∞—é {pct:.2}% –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –∏–∑ –ø–æ–∑–∏—Ü–∏–∏ {from_idx}"),
    ));
    if let Err(e) = decrease_liquidity_partial(mint_from, pct, 500).await {
        let _ = tx.send(ServiceCommand::SendMessage(format!("‚ùå decrease_liquidity: {e}")));
        return;
    }

    // ‚îÄ‚îÄ 6. –ó–∞–º–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å—ã ¬´–ø–æ—Å–ª–µ¬ª –∏ —Å—á–∏—Ç–∞–µ–º –¥–µ–ª—å—Ç—É ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let (sol_after, usdc_after) = refresh_balances(
        &rpc, &wallet.pubkey(), &Pubkey::from_str(USDC).unwrap(), dec_b,
    )
    .await
    .expect("refresh_balances failed");

    let freed_sol  = (sol_after  - sol_before ).max(0.0);
    let freed_usdc = (usdc_after - usdc_before).max(0.0);

    if freed_sol + freed_usdc < 1e-9 {
        let _ = tx.send(ServiceCommand::SendMessage(
            "‚ö†Ô∏è –ù–∏—á–µ–≥–æ –Ω–µ –æ—Å–≤–æ–±–æ–¥–∏–ª–æ—Å—å ‚Äì –æ–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–∫—Ä–∞—â–µ–Ω–∞".into(),
        ));
        return;
    }
    let _ = tx.send(ServiceCommand::SendMessage(format!(
        "‚ûï –°–≤–æ–±–æ–¥–Ω–æ ‚âà {:.6} SOL  /  {:.6} USDC. –î–æ–±–∞–≤–ª—è—é –≤ –ø–æ–∑–∏—Ü–∏—é {to_idx}",
        freed_sol, freed_usdc
    )));

    // ‚îÄ‚îÄ 7. –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –≤ —Ü–µ–ª–µ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if let Err(e) = increase_liquidity_partial(
        mint_to,
        freed_sol,
        freed_usdc,
        &pool_cfg,
        500,
    )
    .await
    {
        let _ = tx.send(ServiceCommand::SendMessage(format!("‚ùå increase_liquidity: {e}")));
        return;
    }

    let _ = tx.send(ServiceCommand::SendMessage("‚úÖ –ü–µ—Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞".into()));
}

fn upper_price(tick_u: i32, dec_a: u8, dec_b: u8) -> f64 {
    tick_index_to_price(tick_u, dec_a, dec_b)
}

