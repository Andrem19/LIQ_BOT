
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey, signature::{read_keypair_file, Keypair}, signer::Signer};
use spl_associated_token_account::get_associated_token_address;
use std::{str::FromStr, time::Duration};
use anyhow::Result;
use tokio::time::sleep;
use anyhow::anyhow;
use orca_whirlpools::PositionOrBundle;
use orca_whirlpools_client::Whirlpool;
use crate::types::PoolConfig;
use std::time::Instant;
use tokio::{sync::Mutex};
use anyhow::bail;

use crate::params::{RPC_URL, POOL, PCT_LIST_1, PCT_LIST_2, ATR_BORDER, WEIGHTS, TOTAL_USDC_SOLUSDC, KEYPAIR_FILENAME};
use crate::types::{LiqPosition, Role};
use crate::orca_logic::helpers::{calc_bound_prices_struct, calc_range_allocation_struct};
use crate::wirlpool_services::wirlpool::{open_with_funds_check_universal, close_all_positions, list_positions_for_owner};
use crate::wirlpool_services::get_info::fetch_pool_position_info;
use crate::telegram_service::tl_engine::ServiceCommand;
use crate::types::WorkerCommand;
use tokio::sync::mpsc::UnboundedSender;
use spl_token::state::Mint;
use std::env;
use crate::params::{WALLET_MUTEX, USDC};
use crate::wirlpool_services::wirlpool::utils;
use crate::types::PoolRuntimeInfo;
use std::sync::Arc;
use spl_token::solana_program::program_pack::Pack;
use crate::exchange::helpers::get_atr_1h;
use crate::orca_logic::helpers::get_sol_price_usd;
use crate::wirlpool_services::wirlpool::close_whirlpool_position;



//-------------------------------- helper -----------------------------------
async fn close_and_report(
    rpc: &RpcClient,
    pool_cfg: &PoolConfig,
    whirl_pk: Pubkey,
    tx_tg: &UnboundedSender<ServiceCommand>,
) -> Result<()> {
    // 1) –∑–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –≠–¢–û–ì–û –ø—É–ª–∞
    close_all_positions(150, Some(whirl_pk)).await?;

    // 2) –ë–∞–ª–∞–Ω—Å—ã –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è
    let _lock   = WALLET_MUTEX.lock().await;              // –µ–¥–∏–Ω—ã–π –∑–∞–º–æ–∫
    let wallet  = utils::load_wallet()?;
    let wallet_pk = wallet.pubkey();

    let lamports = rpc.get_balance(&wallet_pk).await?;
    let bal_sol  = lamports as f64 / 1e9;

    let mint_b  = Pubkey::from_str(pool_cfg.mint_b)?;
    let ata_b   = get_associated_token_address(&wallet_pk, &mint_b);
    let bal_b   = rpc.get_token_account_balance(&ata_b)
        .await?.amount.parse::<f64>()?
        / 10f64.powi(pool_cfg.decimal_b as i32);

    // 3) –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º SOL –≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç —Ç–æ–∫–µ–Ω–∞ B –∏–ª–∏ USDC
    let whirl    = orca_whirlpools_client::Whirlpool::from_bytes(
        &rpc.get_account(&whirl_pk).await?.data)?;
    let price_ab = orca_whirlpools_core::sqrt_price_to_price(
        whirl.sqrt_price.into(),
        pool_cfg.decimal_a as u8,
        pool_cfg.decimal_b as u8,
    );                       // price(B per A): —Å–∫–æ–ª—å–∫–æ B –∑–∞ 1 SOL

    let total_usd = if pool_cfg.mint_b == USDC {
        bal_b + bal_sol * price_ab            // price_ab == USDC per SOL
    } else {
        // –¥–ª—è RAY/SOL —Å—á–∏—Ç–∞–µ–º ¬´—á–µ—Ä–µ–∑ SOL¬ª: –≤—Å—ë –≤ —ç–∫–≤. –¥–æ–ª–ª–∞—Ä—ã
        // –±–µ—Ä—ë–º —Ü–µ–Ω—É SOL-USD –∏–∑ –±–∏—Ä–∂–∏ Jupiter (–æ–¥–∏–Ω HTTP-–∑–∞–ø—Ä–æ—Å)
        let sol_usd: f64 = get_sol_price_usd().await?;
        bal_b * price_ab * sol_usd  +  bal_sol * sol_usd
    };

    // 4) –æ—Ç—á—ë—Ç
    let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
        "üè¶ {} –∑–∞–∫—Ä—ã—Ç.\n‚ñ∫ SOL {:.6}\n‚ñ∫ token B {:.6}\n‚ñ∫ –í—Å–µ–≥–æ ‚âà ${:.2}",
        pool_cfg.name, bal_sol, bal_b, total_usd
    )));
    Ok(())
}


pub async fn orchestrator_pool(
    mut pool_cfg: PoolConfig,          // —à–∞–±–ª–æ–Ω –ø—É–ª–∞
    capital_usd: f64,                  // –æ–±—â–∏–π —Ä–∞–∑–º–µ—Ä ‚Äú–∫–æ—à–µ–ª—å–∫–∞‚Äù –ø–æ–¥ –ø—É–ª
    pct_list: [f64; 4],                // –∫–∞–∫ —Ä–∞–Ω—å—à–µ (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è –¥–ª—è 1-–¥–∏–∞–ø–∞–∑.)
    three_ranges: bool,                // true = SOL/USDC, false = RAY/SOL
    tx_tg: UnboundedSender<ServiceCommand>,
) -> Result<()> {
    close_existing_owner_positions(&pool_cfg).await?;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0. RPC / Whirlpool meta ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let rpc       = utils::init_rpc();
    let whirl_pk  = Pubkey::from_str(pool_cfg.pool_address)?;
    let whirl     = orca_whirlpools_client::Whirlpool::from_bytes(
        &rpc.get_account(&whirl_pk).await?.data
    )?;
    let dec_a     = Mint::unpack(&rpc.get_account(&whirl.token_mint_a).await?.data)?.decimals;
    let dec_b     = Mint::unpack(&rpc.get_account(&whirl.token_mint_b).await?.data)?.decimals;


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut start_time = Instant::now();
    let price_raw = orca_whirlpools_core::sqrt_price_to_price(whirl.sqrt_price.into(), dec_a, dec_b);
    let invert    = !three_ranges;          // false –¥–ª—è SOL/USDC, true –¥–ª—è RAY/SOL
    let price_disp = if invert { 1.0 / price_raw } else { price_raw };
    let mut price = norm_price(price_raw, invert);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã / –∞–ª–ª–æ–∫–∞—Ü–∏–∏  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut upper_exit = 0.0;
    let mut lower_exit = 0.0;

    if three_ranges {
        
        /* === —Ç—Ä—ë—Ö-–¥–∏–∞–ø–∞–∑–æ–Ω–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ –¥–ª—è SOL/USDC ==================== */
        let bounds = calc_bound_prices_struct(price, &pct_list);
        let allocs = calc_range_allocation_struct(price, &bounds, &WEIGHTS, capital_usd);
        
        let _ = tx_tg.send(ServiceCommand::SendMessage(
            format!("üîî –ü—ã—Ç–∞—é—Å—å –æ—Ç–∫—Ä—ã—Ç—å 3 –ø–æ–∑–∏—Ü–∏–∏ SOL/USDC ({} USDC)‚Ä¶", capital_usd)
        ));
        
        let mut minted: Vec<(usize, String)> = Vec::new();   // (index, mint)
        let mut slippage = 150u16;
        
        'outer: for round in 1..=2 {                          // –º–∞–∫—Å–∏–º—É–º 3 —Ä–∞—É–Ω–¥–∞
            let mut progress = false;
        
            for (idx, alloc) in allocs.iter().enumerate() {
                if minted.iter().any(|&(i, _)| i == idx) { continue } // —É–∂–µ –µ—Å—Ç—å
        
                let deposit = if idx == 1 { alloc.usdc_amount } else { alloc.usdc_equivalent };
        
                match open_with_funds_check_universal(
                    alloc.lower_price,
                    alloc.upper_price,
                    deposit,
                    pool_cfg.clone(),
                    slippage,
                ).await {
                    Ok(res) => {
                        // ‚Üì –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –æ—Ç–∫—Ä—ã—Ç—É—é
                        minted.push((idx, res.position_mint.to_string()));
                        progress = true;
        
                        let liq = LiqPosition {
                            role: [Role::Up, Role::Middle, Role::Down][idx].clone(),
                            position_address: None,
                            position_nft:     None,
                            upper_price: alloc.upper_price,
                            lower_price: alloc.lower_price,
                        };
                        match idx {
                            0 => pool_cfg.position_1 = Some(liq),
                            1 => pool_cfg.position_2 = Some(liq),
                            _ => pool_cfg.position_3 = Some(liq),
                        }
        
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("‚úÖ –û—Ç–∫—Ä—ã—Ç–∞ P{} (mint {})", idx + 1, res.position_mint),
                        ));
                    }
                    Err(e) => {
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("‚ö†Ô∏è P{} –Ω–µ –æ—Ç–∫—Ä—ã–ª–∞—Å—å: {e}", idx + 1),
                        ));
                    }
                }
        
                // –º–∞–ª–µ–Ω—å–∫–∏–π ¬´–∫—É–ª-–¥–∞—É–Ω¬ª, —á—Ç–æ–±—ã —Ü–µ–ø–æ—á–∫–∞ tx —É—Å–ø–µ–ª–∞ –ø—Ä–æ–π—Ç–∏
                tokio::time::sleep(std::time::Duration::from_millis(800)).await;
            }
        
            // –µ—Å–ª–∏ —É–∂–µ –≤—Å–µ 3 ‚Äî –≤—ã—Ö–æ–¥–∏–º
            if minted.len() == 3 { break 'outer; }
        
            // –µ—Å–ª–∏ –Ω–µ –ø—Ä–æ–¥–≤–∏–Ω—É–ª–∏—Å—å ‚Äî –ø–æ–≤—ã—à–∞–µ–º slippage
            if !progress { slippage += 100; }
        
            let _ = tx_tg.send(ServiceCommand::SendMessage(
                format!("üîÑ –†–∞—É–Ω–¥ {round} –æ–∫–æ–Ω—á–µ–Ω, –æ—Ç–∫—Ä—ã—Ç–æ {}/3. Slippage = {} bps", minted.len(), slippage)
            ));
        }
        
        // –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        if minted.len() != 3 {
            let _ = tx_tg.send(ServiceCommand::SendMessage(
                format!("‚ùå –ó–∞ 3 —Ä–∞—É–Ω–¥–∞ –æ—Ç–∫—Ä—ã—Ç–æ —Ç–æ–ª—å–∫–æ {}/3. –ó–∞–∫—Ä—ã–≤–∞—é —Ç–æ, —á—Ç–æ –±—ã–ª–æ.", minted.len())
            ));
        
            for &(_, ref pm) in &minted {
                let _ = close_whirlpool_position(Pubkey::from_str(pm)?, 150u16).await;
            }
            bail!("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –≤—Å–µ —Ç—Ä–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞");
        }
        
        upper_exit = pool_cfg.position_1.as_ref().unwrap().upper_price;
        lower_exit = pool_cfg.position_3.as_ref().unwrap().lower_price;
    } else {
        // –¥–∏–∞–ø–∞–∑–æ–Ω –≤ —É–¥–æ–±–Ω–æ–º (SOL –∑–∞ RAY) –≤–∏–¥–µ
        let low_disp  = price_disp * 0.995;
        let high_disp = price_disp * 1.005;

        let sol_usd  = get_sol_price_usd().await?;
        let tok_b_usd  = price * sol_usd;          // USD-—Ü–µ–Ω–∞ 1 RAY
        let amount_tok_b = (capital_usd / 2.0) / tok_b_usd;

        // -- –≤—ã–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é --
        let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
            "üîî –û—Ç–∫—Ä—ã–≤–∞—é —Ü–µ–Ω—Ç—Ä {} [{:.6}; {:.6}], –≤–µ—Å ${:.2} amount Tok_b: {:.2}",
            pool_cfg.name, low_disp, high_disp, capital_usd, amount_tok_b
        )));

        // –≥—Ä–∞–Ω–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω—ã SDK (RAY –∑–∞ SOL)
        let low_raw  = 1.0 / high_disp;
        let high_raw = 1.0 / low_disp;

        open_with_funds_check_universal(
            low_raw,
            high_raw,
            amount_tok_b,          // –∫–∞–∫ –±—ã–ª–æ
            pool_cfg.clone(),
            150,
        ).await?;

        pool_cfg.position_2 = Some(LiqPosition {
            role:          Role::Middle,
            position_address: None,
            position_nft:     None,
            upper_price: high_disp,     // —Ö—Ä–∞–Ω–∏–º –∏ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º –≤ display-–≤–∏–¥–µ
            lower_price: low_disp,
        });
        upper_exit = high_disp;
        lower_exit = low_disp;
    }


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut price_itv  = tokio::time::interval(Duration::from_secs(5));

    loop {
        tokio::select! {
            _ = price_itv.tick() => {
                let curr_raw = orca_whirlpools_core::sqrt_price_to_price(
                    orca_whirlpools_client::Whirlpool::from_bytes(
                        &rpc.get_account(&whirl_pk).await?.data
                    )?.sqrt_price.into(), dec_a, dec_b
                );

                price = norm_price(curr_raw, invert);

                let kof = if pool_cfg.name != "SOL/USDC" {
                    0.008
                } else {
                    0.0015
                };
            
                if price > upper_exit * (1.0+kof) || price < lower_exit * (1.0-kof) {
                    let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
                        "‚ö†Ô∏è {}: price {:.6} –≤—ã—à–ª–∞ –∑–∞ [{:.6}; {:.6}] ‚Äî –∑–∞–∫—Ä—ã–≤–∞—é –ø–æ–∑–∏—Ü–∏–∏",
                        pool_cfg.name, price, lower_exit, upper_exit
                    )));
            
                    //   ‚áì  –Ω–æ–≤–æ–µ –≤—ã–∑–≤–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
                    if let Err(e) = close_and_report(&rpc, &pool_cfg, whirl_pk, &tx_tg).await {
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ {}: {:?}", pool_cfg.name, e)
                        ));
                    }
                    break;          // main –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç –∫–æ—Ä—É—Ç–∏–Ω—É
                }
            }
            
        }
    }

    Ok(())
}


#[inline]
fn norm_price(raw: f64, invert: bool) -> f64 {
    if invert { 1.0 / raw } else { raw }
}

// reporter.rs
pub async fn build_pool_report(cfg: &PoolConfig) -> anyhow::Result<String> {

    let rpc = utils::init_rpc();
    let whirl_pk = Pubkey::from_str(cfg.pool_address)?;
    let whirl_acct = rpc.get_account(&whirl_pk).await?;
    let whirl = orca_whirlpools_client::Whirlpool::from_bytes(&whirl_acct.data)?;

    // —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞
    let da = cfg.decimal_a;
    let db = cfg.decimal_b;
    let raw = orca_whirlpools_core::sqrt_price_to_price(whirl.sqrt_price.into(), da as u8, db as u8);
    let price_disp = if cfg.name == "RAY/SOL" { 1.0 / raw } else { raw };

    // –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ owner-a –≤ —ç—Ç–æ–º –ø—É–ª–µ
    let list = list_positions_for_owner(Some(whirl_pk)).await?;  // ‚Üê –≤–∞—à–∞ –æ–±—ë—Ä—Ç–∫–∞ SDK
    if list.is_empty() {
        return Ok(format!("üìä {} ‚Äî –ø–æ–∑–∏—Ü–∏–π –Ω–µ—Ç.\n", cfg.name));
    }

    // —Å–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ –ø–æ –ø–æ–∑–∏—Ü–∏—è–º
    let mut infos = Vec::new();
    for p in list {
        if let PositionOrBundle::Position(hp) = p {
            if let Ok(i) = fetch_pool_position_info(cfg, Some(&hp.address.to_string())).await {
                infos.push(i);
            }
        }
    }

    // —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ lower_price (—á—Ç–æ–±—ã üçèüçäüçé —à–ª–∏ ¬´—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑¬ª)
    infos.sort_by(|a,b| a.lower_price.partial_cmp(&b.lower_price).unwrap());

    // –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç—á—ë—Ç
    let mut rep = format!("üìä {} ‚Äî Price {:.6}\n", cfg.name, price_disp);
    let icons = ["üçè","üçä","üçé"];
    let mut total = 0.0;
    for (idx, i) in infos.iter().enumerate() {
        let sym = if price_disp > i.lower_price && price_disp < i.upper_price {
            icons.get(idx).unwrap_or(&"‚úÖ")
        } else { "----" };
        rep.push_str(&format!(
            "{}P{}: R[{:.4}‚Äì{:.4}], ${:.4}\n",
            sym, idx+1, i.lower_price, i.upper_price, i.sum
        ));
        total += i.sum;
    }
    rep.push_str(&format!("‚Äî –í—Å–µ–≥–æ: ${:.4}\n\n", total));
    Ok(rep)
}

async fn close_existing_owner_positions(pool: &PoolConfig) -> anyhow::Result<()> {
    let list = list_positions_for_owner(Some(Pubkey::from_str(pool.pool_address)?)).await?;
    for p in list {
        if let PositionOrBundle::Position(pos) = p {
            // –∑–∞–∫—Ä—ã–≤–∞–µ–º –ª—é–±—É—é –ø–æ–∑–∏—Ü–∏—é owner-–∞ –≤ —ç—Ç–æ–º –ø—É–ª–µ
            let _ = close_whirlpool_position(pos.data.position_mint, 150.0 as u16).await;
        }
    }
    Ok(())
}