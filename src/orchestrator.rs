
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey, signature::{read_keypair_file, Keypair}, signer::Signer};
use spl_associated_token_account::get_associated_token_address;
use std::{str::FromStr, time::Duration};
use anyhow::Result;
use orca_whirlpools::PositionOrBundle;
use crate::types::PoolConfig;
use std::time::Instant;
use std::sync::atomic::AtomicBool;
use orca_whirlpools_core::U128;
use anyhow::bail;
use std::env;
use dotenv::dotenv;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering;

use crate::params::{WEIGHTS};
use crate::types::{LiqPosition, Role};
use crate::orca_logic::helpers::{calc_bound_prices_struct, calc_range_allocation_struct};
use crate::wirlpool_services::wirlpool::{open_with_funds_check_universal, close_all_positions, list_positions_for_owner};
use crate::wirlpool_services::get_info::fetch_pool_position_info;
use crate::telegram_service::tl_engine::ServiceCommand;
use crate::types::WorkerCommand;
use tokio::sync::mpsc::UnboundedSender;
use spl_token::state::Mint;
use tokio::sync::Notify;
use crate::database::triggers;

use crate::params::{WALLET_MUTEX, USDC};
use crate::utils::utils;
use crate::utils::{safe_get_account, swap_excess_to_usdc};
use crate::types::PoolRuntimeInfo;
use std::sync::Arc;
use crate::params::{WSOL};
use spl_token::solana_program::program_pack::Pack;
use crate::exchange::helpers::get_atr_1h;
use crate::orca_logic::helpers::get_sol_price_usd;
use crate::wirlpool_services::wirlpool::close_whirlpool_position;



//-------------------------------- helper -----------------------------------
async fn close_and_report(
    rpc: &RpcClient,
    pool_cfg: &PoolConfig,
    whirl_pk: Pubkey,
    tx_tg: &UnboundedSender<ServiceCommand>,
    lower: bool,
) -> Result<()> {
    // 1) –∑–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –≠–¢–û–ì–û –ø—É–ª–∞
    close_all_positions(150, Some(whirl_pk)).await?;
    if lower {
        _ = swap_excess_to_usdc(WSOL, 9, 0.05).await?;
        triggers::auto_trade_switch(true, tx_tg).await?;
    }

    // 2) –ë–∞–ª–∞–Ω—Å—ã –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è
    let _lock   = WALLET_MUTEX.lock().await;              // –µ–¥–∏–Ω—ã–π –∑–∞–º–æ–∫
    let wallet  = utils::load_wallet()?;
    let wallet_pk = wallet.pubkey();

    let lamports = rpc.get_balance(&wallet_pk).await?;
    let bal_sol  = lamports as f64 / 1e9;

    let mint_b  = Pubkey::from_str(pool_cfg.mint_b)?;
    let ata_b   = get_associated_token_address(&wallet_pk, &mint_b);
    let bal_b   = rpc.get_token_account_balance(&ata_b)
        .await?.amount.parse::<f64>()?
        / 10f64.powi(pool_cfg.decimal_b as i32);

    // 3) –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º SOL –≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç —Ç–æ–∫–µ–Ω–∞ B –∏–ª–∏ USDC
    let whirl_acct = safe_get_account(&rpc, &whirl_pk).await?;
    let whirl = orca_whirlpools_client::Whirlpool::from_bytes(&whirl_acct.data)?;
    let price_ab = orca_whirlpools_core::sqrt_price_to_price(
        whirl.sqrt_price.into(),
        pool_cfg.decimal_a as u8,
        pool_cfg.decimal_b as u8,
    );                       // price(B per A): —Å–∫–æ–ª—å–∫–æ B –∑–∞ 1 SOL

    let total_usd = if pool_cfg.mint_b == USDC {
        bal_b + bal_sol * price_ab            // price_ab == USDC per SOL
    } else {
        // –¥–ª—è RAY/SOL —Å—á–∏—Ç–∞–µ–º ¬´—á–µ—Ä–µ–∑ SOL¬ª: –≤—Å—ë –≤ —ç–∫–≤. –¥–æ–ª–ª–∞—Ä—ã
        // –±–µ—Ä—ë–º —Ü–µ–Ω—É SOL-USD –∏–∑ –±–∏—Ä–∂–∏ Jupiter (–æ–¥–∏–Ω HTTP-–∑–∞–ø—Ä–æ—Å)
        let sol_usd: f64 = get_sol_price_usd().await?;
        bal_b * price_ab * sol_usd  +  bal_sol * sol_usd
    };

    // 4) –æ—Ç—á—ë—Ç
    let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
        "üè¶ {} –∑–∞–∫—Ä—ã—Ç.\n‚ñ∫ SOL {:.6}\n‚ñ∫ token B {:.6}\n‚ñ∫ –í—Å–µ–≥–æ ‚âà ${:.2}",
        pool_cfg.name, bal_sol, bal_b, total_usd
    )));
    Ok(())
}


pub async fn orchestrator_pool(
    mut pool_cfg: PoolConfig,          // —à–∞–±–ª–æ–Ω –ø—É–ª–∞
    capital_usd: f64,                  // –æ–±—â–∏–π —Ä–∞–∑–º–µ—Ä ‚Äú–∫–æ—à–µ–ª—å–∫–∞‚Äù –ø–æ–¥ –ø—É–ª
    pct_list: [f64; 4],                // –∫–∞–∫ —Ä–∞–Ω—å—à–µ (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è –¥–ª—è 1-–¥–∏–∞–ø–∞–∑.)
    three_ranges: bool,                // true = SOL/USDC, false = RAY/SOL
    tx_tg: UnboundedSender<ServiceCommand>,
    need_new: Arc<AtomicBool>,
    close_ntf:    Arc<Notify>,
    min_restart: u64,
    range: Option<f32>,
) -> Result<()> {
    let need_open_new = need_new.load(Ordering::SeqCst);
    need_new.store(true, Ordering::SeqCst);
    
    if need_open_new {
        close_existing_owner_positions(&pool_cfg).await?;
    }
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0. RPC / Whirlpool meta ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let rpc       = utils::init_rpc();
    let whirl_pk  = Pubkey::from_str(pool_cfg.pool_address)?;
    let whirl_acct = safe_get_account(&rpc, &whirl_pk).await?;
    let whirl = orca_whirlpools_client::Whirlpool::from_bytes(&whirl_acct.data)?;
    let dec_a     = Mint::unpack(&rpc.get_account(&whirl.token_mint_a).await?.data)?.decimals;
    let dec_b     = Mint::unpack(&rpc.get_account(&whirl.token_mint_b).await?.data)?.decimals;


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut start_time = Instant::now();
    let price_raw = orca_whirlpools_core::sqrt_price_to_price(whirl.sqrt_price.into(), dec_a, dec_b);
    let invert    = !three_ranges;          // false –¥–ª—è SOL/USDC, true –¥–ª—è RAY/SOL
    let price_disp = if invert { 1.0 / price_raw } else { price_raw };
    let mut price = norm_price(price_raw, invert);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã / –∞–ª–ª–æ–∫–∞—Ü–∏–∏  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut upper_exit = 0.0;
    let mut lower_exit = 0.0;

    if three_ranges && need_open_new {
        
        /* === —Ç—Ä—ë—Ö-–¥–∏–∞–ø–∞–∑–æ–Ω–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ –¥–ª—è SOL/USDC ==================== */
        let bounds = calc_bound_prices_struct(price, &pct_list);
        let allocs = calc_range_allocation_struct(price, &bounds, &WEIGHTS, capital_usd);
        
        let _ = tx_tg.send(ServiceCommand::SendMessage(
            format!("üîî –ü—ã—Ç–∞—é—Å—å –æ—Ç–∫—Ä—ã—Ç—å 3 –ø–æ–∑–∏—Ü–∏–∏ SOL/USDC ({} USDC)‚Ä¶", capital_usd)
        ));
        
        let mut minted: Vec<(usize, String)> = Vec::new();   // (index, mint)
        let mut slippage = 150u16;
        
        'outer: for round in 1..=2 {                          // –º–∞–∫—Å–∏–º—É–º 3 —Ä–∞—É–Ω–¥–∞
            let mut progress = false;
        
            for (idx, alloc) in allocs.iter().enumerate() {
                if minted.iter().any(|&(i, _)| i == idx) { continue } // —É–∂–µ –µ—Å—Ç—å
        
                let deposit = if idx == 1 { alloc.usdc_amount } else { alloc.usdc_equivalent };
        
                match open_with_funds_check_universal(
                    alloc.lower_price,
                    alloc.upper_price,
                    deposit,
                    pool_cfg.clone(),
                    slippage,
                ).await {
                    Ok(res) => {
                        // ‚Üì –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –æ—Ç–∫—Ä—ã—Ç—É—é
                        minted.push((idx, res.position_mint.to_string()));
                        progress = true;
        
                        let liq = LiqPosition {
                            role: [Role::Up, Role::Middle, Role::Down][idx].clone(),
                            position_address: None,
                            position_nft:     None,
                            upper_price: alloc.upper_price,
                            lower_price: alloc.lower_price,
                        };
                        match idx {
                            0 => pool_cfg.position_1 = Some(liq),
                            1 => pool_cfg.position_2 = Some(liq),
                            _ => pool_cfg.position_3 = Some(liq),
                        }
        
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("‚úÖ –û—Ç–∫—Ä—ã—Ç–∞ P{} (mint {})", idx + 1, res.position_mint),
                        ));
                    }
                    Err(e) => {
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("‚ö†Ô∏è P{} –Ω–µ –æ—Ç–∫—Ä—ã–ª–∞—Å—å: {e}", idx + 1),
                        ));
                    }
                }
        
                // –º–∞–ª–µ–Ω—å–∫–∏–π ¬´–∫—É–ª-–¥–∞—É–Ω¬ª, —á—Ç–æ–±—ã —Ü–µ–ø–æ—á–∫–∞ tx —É—Å–ø–µ–ª–∞ –ø—Ä–æ–π—Ç–∏
                tokio::time::sleep(std::time::Duration::from_millis(800)).await;
            }
        
            // –µ—Å–ª–∏ —É–∂–µ –≤—Å–µ 3 ‚Äî –≤—ã—Ö–æ–¥–∏–º
            if minted.len() == 3 { break 'outer; }
        
            // –µ—Å–ª–∏ –Ω–µ –ø—Ä–æ–¥–≤–∏–Ω—É–ª–∏—Å—å ‚Äî –ø–æ–≤—ã—à–∞–µ–º slippage
            if !progress { slippage += 100; }
        
            let _ = tx_tg.send(ServiceCommand::SendMessage(
                format!("üîÑ –†–∞—É–Ω–¥ {round} –æ–∫–æ–Ω—á–µ–Ω, –æ—Ç–∫—Ä—ã—Ç–æ {}/3. Slippage = {} bps", minted.len(), slippage)
            ));
        }
        
        // –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        if minted.len() != 3 {
            let _ = tx_tg.send(ServiceCommand::SendMessage(
                format!("‚ùå –ó–∞ 3 —Ä–∞—É–Ω–¥–∞ –æ—Ç–∫—Ä—ã—Ç–æ —Ç–æ–ª—å–∫–æ {}/3. –ó–∞–∫—Ä—ã–≤–∞—é —Ç–æ, —á—Ç–æ –±—ã–ª–æ.", minted.len())
            ));
        
            for &(_, ref pm) in &minted {
                let _ = close_whirlpool_position(Pubkey::from_str(pm)?, 150u16).await;
            }
            bail!("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –≤—Å–µ —Ç—Ä–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞");
        }
        
        upper_exit = pool_cfg.position_1.as_ref().unwrap().upper_price;
        lower_exit = pool_cfg.position_3.as_ref().unwrap().lower_price;
    } else if need_open_new {
        // ‚îÄ‚îÄ 1. –¢–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –≤ ‚ÄúSOL –∑–∞ —Ç–æ–∫–µ–Ω-B‚Äù (display) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        let (low_perc, high_perc) = match calculate_range(range) {
            Some((low, high)) => (low, high),
            None => {
                println!("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã—á–∏—Å–ª–∏—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω");
                return Ok(()); // –∏–ª–∏ return Err(...), –µ—Å–ª–∏ –≤ async fn
            }
        };
        let low_disp  = low_perc * price_disp;
        let high_disp = high_perc * price_disp;
        println!("range: {} - {}", low_disp, high_disp);


        // ‚îÄ‚îÄ 2. –¶–µ–Ω–∞ 1 —Ç–æ–∫–µ–Ω–∞-B –≤ SOL, –∞ –∑–∞—Ç–µ–º –≤ USD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let price_b_in_sol = price_disp;                 // invert –≤—Å–µ–≥–¥–∞ true –∑–¥–µ—Å—å
        let sol_usd        = get_sol_price_usd().await?;
        let tok_b_usd      = price_b_in_sol * sol_usd;   // ETH ‚âà 2 400 $, RAY ‚âà 2 $

        // ‚îÄ‚îÄ 3. –°–∫–æ–ª—å–∫–æ B –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –∑–∞–Ω—è—Ç—å –ø–æ–ª–æ–≤–∏–Ω—É –∫–∞–ø–∏—Ç–∞–ª–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let amount_tok_b = (capital_usd / 2.0) / tok_b_usd;

        // ‚Äî Telegram + DEBUG ‚Äî
        let telegram_msg = format!(
            "üîî –û—Ç–∫—Ä—ã–≤–∞—é —Ü–µ–Ω—Ç—Ä {} [{:.6}; {:.6}], –≤–µ—Å ${:.2} amount Tok_b: {:.6}",
            pool_cfg.name, low_disp, high_disp, capital_usd, amount_tok_b
        );
        println!(
            "DBG: B_in_SOL={:.6}, tok_b_usd={:.2}, amount_tok_b={:.6}",
            price_b_in_sol, tok_b_usd, amount_tok_b
        );
        let _ = tx_tg.send(ServiceCommand::SendMessage(telegram_msg));

        // ‚îÄ‚îÄ 4. –ì—Ä–∞–Ω–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –∂–¥—ë—Ç SDK (B –∑–∞ SOL) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let low_raw  = 1.0 / high_disp;
        let high_raw = 1.0 / low_disp;

        // ‚îÄ‚îÄ 5. –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        open_with_funds_check_universal(
            low_raw,
            high_raw,
            amount_tok_b,
            pool_cfg.clone(),
            150,
        ).await?;


        pool_cfg.position_2 = Some(LiqPosition {
            role:          Role::Middle,
            position_address: None,
            position_nft:     None,
            upper_price: high_disp,     // —Ö—Ä–∞–Ω–∏–º –∏ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º –≤ display-–≤–∏–¥–µ
            lower_price: low_disp,
        });
        upper_exit = high_disp;
        lower_exit = low_disp;
    } else {
        //------------------------------------------------------------------
        //  ‚ú¶  –ë–ª–æ–∫, –∫–æ–≥–¥–∞ –ø–æ–∑–∏—Ü–∏–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç (need_open_new == false) ‚ú¶
        //------------------------------------------------------------------

        // 1) –ø–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ —Ç–µ–∫—É—â–µ–≥–æ owner-–∞ –≤ –¥–∞–Ω–Ω–æ–º –ø—É–ª–µ
        let list = list_positions_for_owner(Some(whirl_pk)).await?;
        if list.is_empty() {
            bail!("need_open_new == false, –Ω–æ –≤ –ø—É–ª–µ {} –Ω–µ—Ç –Ω–∏ –æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏", pool_cfg.name);
        }

        // 2) —Å–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –µ—ë –ø–æ lower_price
        let mut infos = Vec::<crate::types::PoolPositionInfo>::new();
        for p in list {
            if let PositionOrBundle::Position(hp) = p {
                if let Ok(i) = fetch_pool_position_info(&pool_cfg, Some(&hp.address.to_string())).await {
                    infos.push(i);
                }
            }
        }
        infos.sort_by(|a, b| {
            // —Ç–µ–ø–µ—Ä—å —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–Ω–∞—á–∞–ª–∞ b —Å a
            b.lower_price.partial_cmp(&a.lower_price).unwrap()
        });

        // 3) –∑–∞–ø–æ–ª–Ω—è–µ–º pool_cfg –∏ –≥—Ä–∞–Ω–∏—Ü—ã –≤—ã—Ö–æ–¥–∞
        if three_ranges {
            // –æ–∂–∏–¥–∞–µ–º —Ä–æ–≤–Ω–æ 3 –¥–∏–∞–ø–∞–∑–æ–Ω–∞
            if infos.len() != 3 {
                bail!("–í –ø—É–ª–µ {} –Ω–∞–π–¥–µ–Ω–æ {} –ø–æ–∑–∏—Ü–∏–π, –∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 3", pool_cfg.name, infos.len());
            }

            pool_cfg.position_1 = Some(LiqPosition {
                role: Role::Up,
                position_address: None,
                position_nft:     None,
                upper_price: infos[0].upper_price,
                lower_price: infos[0].lower_price,
            });
            pool_cfg.position_2 = Some(LiqPosition {
                role: Role::Middle,
                position_address: None,
                position_nft:     None,
                upper_price: infos[1].upper_price,
                lower_price: infos[1].lower_price,
            });
            pool_cfg.position_3 = Some(LiqPosition {
                role: Role::Down,
                position_address: None,
                position_nft:     None,
                upper_price: infos[2].upper_price,
                lower_price: infos[2].lower_price,
            });

            // ¬´–≤–µ—Ä—Ö–Ω–∏–π –≤—ã–ª–µ—Ç¬ª –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –ø–µ—Ä–≤–æ–π (Up) –ø–æ–∑–∏—Ü–∏–∏,
            // ¬´–Ω–∏–∂–Ω–∏–π –≤—ã–ª–µ—Ç¬ª ‚Äî –ø–æ –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ —Ç—Ä–µ—Ç—å–µ–π (Down), –∫–∞–∫ –∏ —Ä–∞–Ω—å—à–µ
            upper_exit = infos[0].upper_price;
            lower_exit = infos[2].lower_price;
        } else {
            // –æ–¥–∏–Ω–æ—á–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω (RAY/SOL, WETH/SOL) ‚Äì –±–µ—Ä—ë–º –ø–µ—Ä–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            let i = &infos[0];
            pool_cfg.position_2 = Some(LiqPosition {
                role: Role::Middle,
                position_address: None,
                position_nft:     None,
                upper_price: i.upper_price,
                lower_price: i.lower_price,
            });
            upper_exit = i.upper_price;
            lower_exit = i.lower_price;
        }

        // 4) –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
            "üîÑ {}: –Ω–∞–π–¥–µ–Ω–æ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π {:} ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥—É",
            pool_cfg.name, infos.len()
        )));
    }


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let mut price_itv  = tokio::time::interval(Duration::from_secs(15));

    let mut out_of_range_since: Option<Instant> = None;       // —Ç–æ–ª—å–∫–æ –¥–ª—è ¬´–æ–¥–Ω–æ–¥–∏–∞–ø–∞–∑–æ–Ω–Ω—ã—Ö¬ª
    let mut wait_before_redeploy = if pool_cfg.name == "SOL/USDC" {
        Duration::from_secs(min_restart * 60)
    } else {
        Duration::from_secs(min_restart * 60)
    };

    loop {
        tokio::select! {
            _ = price_itv.tick() => {
                // 3.1 –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
                let acct  = match safe_get_account(&rpc, &whirl_pk).await {
                    Ok(a) => a,
                    Err(e) => {           // —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç —Ç–∏–∫
                        let _ = tx_tg.send(ServiceCommand::SendMessage(
                            format!("üåê {}: RPC error ({e}), –∂–¥—ë–º —Å–ª–µ–¥—É—é—â–∏–π —Ç–∏–∫", pool_cfg.name)));
                        continue;
                    }
                };
                let curr_raw = orca_whirlpools_core::sqrt_price_to_price(
                    orca_whirlpools_client::Whirlpool::from_bytes(&acct.data)?.sqrt_price.into(),
                    dec_a, dec_b
                );
                let invert = if pool_cfg.name != "SOL/USDC" {true} else {false};
                price = norm_price(curr_raw, invert);

                // 3.2 –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ
                let kof = 0.0015;


                let out_of_range = price > upper_exit * (1.0 + kof) ||
                                price < lower_exit;

                // println!(
                //     "‚ö†Ô∏è {}: price {:.6} [{:.6}; {:.6}].",
                //     pool_cfg.name, price, lower_exit, upper_exit
                // );

                // // ‚îÄ‚îÄ A)  –ø—É–ª SOL/USDC ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // if pool_cfg.name == "SOL/USDC" {
                //     if out_of_range {
                //         let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
                //             "‚ö†Ô∏è {}: price {:.6} –≤—ã—à–ª–∞ –∑–∞ [{:.6}; {:.6}] ‚Äî –∑–∞–∫—Ä—ã–≤–∞—é –ø–æ–∑–∏—Ü–∏–∏",
                //             pool_cfg.name, price, upper_exit, upper_exit
                //         )));
                //         if let Err(e) = close_and_report(&rpc, &pool_cfg, whirl_pk, &tx_tg).await {
                //             let _ = tx_tg.send(ServiceCommand::SendMessage(
                //                 format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ {}: {:?}", pool_cfg.name, e)
                //             ));
                //         }
                //         break;      // run_pool_with_restart –∑–∞–ø—É—Å—Ç–∏—Ç –≤—Å—ë –∑–∞–Ω–æ–≤–æ
                //     }
                //     continue;       // –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É tick
                // }

                // ‚îÄ‚îÄ B)  –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—É–ª—ã ‚Äî –∂–¥—ë–º 1 —á, –≤–µ—Ä–Ω—ë—Ç—Å—è –ª–∏ —Ü–µ–Ω–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if out_of_range {
                    if price < lower_exit {
                        wait_before_redeploy = Duration::from_secs(0);
                    }
                    match out_of_range_since {
                        // –ø–µ—Ä–≤—ã–π –≤—ã—Ö–æ–¥ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã ‚Äî –∑–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
                        None => {
                            out_of_range_since = Some(Instant::now());
                            let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
                                "‚ö†Ô∏è {}: price {:.6} –≤—ã—à–ª–∞ –∑–∞ [{:.6}; {:.6}]. \
                                –ñ–¥—ë–º {:.2} min",
                                pool_cfg.name, price, lower_exit, upper_exit, min_restart
                            )));
                        }
                        // —Ç–∞–π–º–µ—Ä —É–∂–µ –∏–¥—ë—Ç ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, –∏—Å—Ç—ë–∫ –ª–∏ —á–∞—Å
                        Some(t0) if t0.elapsed() >= wait_before_redeploy => {
                            let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
                                "‚è∞ {}: –ø—Ä–æ—à–ª–æ {:.2} min, —Ü–µ–Ω–∞ {:.6} –≤—Å—ë –µ—â—ë –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ‚Äî \
                                –ø–µ—Ä–µ–≤—ã—Å—Ç–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏",
                                pool_cfg.name, min_restart, price
                            )));
                            let lower = if price < lower_exit { true } else { false };
                            if let Err(e) = close_and_report(&rpc, &pool_cfg, whirl_pk, &tx_tg, lower).await {
                                let _ = tx_tg.send(ServiceCommand::SendMessage(
                                    format!("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ {}: {:?}", pool_cfg.name, e)
                                ));
                            }
                            break;      // main –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç –∫–æ—Ä—É—Ç–∏–Ω—É –∏ –æ—Ç–∫—Ä–æ–µ—Ç –∑–∞–Ω–æ–≤–æ
                        }
                        _ => {} // –µ—â—ë –Ω–µ –ø—Ä–æ—à—ë–ª —á–∞—Å ‚Äî –ø—Ä–æ—Å—Ç–æ –∂–¥—ë–º
                    }
                } else {
                    // —Ü–µ–Ω–∞ –≤–µ—Ä–Ω—É–ª–∞—Å—å –≤–Ω—É—Ç—Ä—å –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä (–µ—Å–ª–∏ –±—ã–ª)
                    if out_of_range_since.is_some() {
                        let _ = tx_tg.send(ServiceCommand::SendMessage(format!(
                            "‚úÖ {}: price {:.6} —Å–Ω–æ–≤–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É",
                            pool_cfg.name, price
                        )));
                        out_of_range_since = None;
                    }
                }
            }
            _ = close_ntf.notified() => {
                let _ = tx_tg.send(ServiceCommand::SendMessage(
                    format!("üîî {}: –ø–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª CLOSE ALL ‚Äî –≤—ã—Ö–æ–¥–∏–º –∏–∑ –ø—É–ª–∞", pool_cfg.name)
                ));
                // –ø—Ä–æ—Å—Ç–æ –≤—ã—Ö–æ–¥–∏–º: run_pool_with_restart –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç
                break;
            }
        }
    }

    Ok(())
}


#[inline]
fn norm_price(raw: f64, invert: bool) -> f64 {
    if invert { 1.0 / raw } else { raw }
}
pub struct PoolReport {
    pub text:   String, // –≥–æ—Ç–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è Telegram
    pub total:  f64,    // –∏—Ç–æ–≥–æ–≤–∞—è $-—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∑–∏—Ü–∏–π
}
// reporter.rs
pub async fn build_pool_report(cfg: &PoolConfig) -> Result<PoolReport> {
    // 1. RPC / Whirlpool
    let rpc      = utils::init_rpc();
    let whirl_pk = Pubkey::from_str(cfg.pool_address)?;
    let whirl_ac = safe_get_account(&rpc, &whirl_pk).await?;
    let whirl    = orca_whirlpools_client::Whirlpool::from_bytes(&whirl_ac.data)?;

    // 2. –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞
    let raw = orca_whirlpools_core::sqrt_price_to_price(U128::from(whirl.sqrt_price),
                                  cfg.decimal_a as u8, cfg.decimal_b as u8);
    let price_disp = if cfg.name.starts_with("SOL/") { raw } else { 1.0 / raw };

    // 3. –í—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –≤–ª–∞–¥–µ–ª—å—Ü–∞
    let list = list_positions_for_owner(Some(whirl_pk)).await?;
    if list.is_empty() {
        return Ok(PoolReport{
            text:  format!("üìä {} ‚Äî –ø–æ–∑–∏—Ü–∏–π –Ω–µ—Ç.\n", cfg.name),
            total: 0.0,
        });
    }

    // 4. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –ø–æ–∑–∏—Ü–∏—è–º
    let mut infos = Vec::new();
    for p in list {
        if let PositionOrBundle::Position(hp) = p {
            if let Ok(i) = fetch_pool_position_info(cfg, Some(&hp.address.to_string())).await {
                infos.push(i);
            }
        }
    }
    infos.sort_by(|a, b| b.lower_price.partial_cmp(&a.lower_price).unwrap());

    // 5. –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—É–º–º–∏—Ä—É–µ–º total
    let icons = ["üçè","üçä","üçé"];
    let mut txt   = format!("üìä {} ‚Äî Price {:.6}\n", cfg.name, price_disp);
    let mut total = 0.0;
    let mut tv    = 0.0;

    for (idx, i) in infos.iter().enumerate() {
        let l = if cfg.name == "SOL/USDT" { 1.0/i.upper_price } else { i.lower_price };
        let u = if cfg.name == "SOL/USDT" { 1.0/i.lower_price } else { i.upper_price };
        let mark = if price_disp > l && price_disp < u {
            icons.get(idx).unwrap_or(&"‚úÖ")
        } else { "----" };
        txt.push_str(&format!("{mark}P{}: R[{:.4}‚Äì{:.4}], ${:.4}\n", idx+1, l, u, i.sum));
        total += i.sum;
        tv    += i.value_a + i.value_b;
    }
    txt.push_str(&format!("‚Äî TV: {:.2}\n‚Äî –í—Å–µ–≥–æ: ${:.4}\n\n", tv, total));

    Ok(PoolReport { text: txt, total })
}

async fn close_existing_owner_positions(pool: &PoolConfig) -> anyhow::Result<()> {
    let list = list_positions_for_owner(Some(Pubkey::from_str(pool.pool_address)?)).await?;
    for p in list {
        if let PositionOrBundle::Position(pos) = p {
            // –∑–∞–∫—Ä—ã–≤–∞–µ–º –ª—é–±—É—é –ø–æ–∑–∏—Ü–∏—é owner-–∞ –≤ —ç—Ç–æ–º –ø—É–ª–µ
            let _ = close_whirlpool_position(pos.data.position_mint, 150.0 as u16).await;
        }
    }
    Ok(())
}

pub fn calculate_range(range: Option<f32>) -> Option<(f64, f64)>{
    let value = match range {
        Some(v) => v,
        None => {
            println!("–ó–Ω–∞—á–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç");
            return None;
        }
    };
    let half = value /2.0;
    Some((1.0-half as f64, 1.0+half as f64))
}